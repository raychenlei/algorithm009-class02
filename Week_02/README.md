## Week02-学习笔记

### HashMap

* HashMap 继承于AbstractMap，但没实现NavigableMap接口，所以不保证key有序
* HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。
* HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
* HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。
* HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。
* 容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。
* 当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。
* 默认加载因子是 0.75，加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）
* HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的
* table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的"key-value键值对"都是存储在Entry数组中的。
* HashMap将“key为null”的元素都放在table的位置0处，即table[0]中；“key不为null”的放在table的其余位置！
* 将key散列的方法：对数组大小取模

#### HashMap的扩容机制

- 超过了阈值，就将容量扩大两倍，新建一个entry数组，将所有数据进行rehash，确定位置
- 经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置
- 旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置（jdk7）
- 扩容是一个特别耗性能的操作，所以在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。

#### Java中的Hash算法

Hash算法本质上就是三步：取key的hashCode值、高16位运算、取模运算。
模运算的消耗还是比较大的，在HashMap中是这样做的：调用与运算代替取模来计算该对象应该保存在table数组的哪个索引处。这个方法非常巧妙，它通过h & (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。

#### Java8中的HashMap

从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）
![Image](https://gitee.com/raychenlei/pic_bed/raw/master/img/20200531181622.png)

当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。
在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。

### HashSet

* HashSet 是一个没有重复元素的集合。
* 它是由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null 元素。
* HashSet的本质是一个"没有重复元素"的集合，它是通过HashMap实现的。HashSet中含有一个"HashMap类型的成员变量"map，HashSet的操作函数，实际上都是通过map实现的。

### 二叉树

#### 二叉树的几种常见类型

* 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树
* 完全二叉树：叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。
* 平衡二叉树：左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树



#### 二叉树的遍历

* 前序遍历DLR：根-左-右
* 中序遍历LDR：左-根-右
* 后续遍历LRD：左-右-根

二叉树的相关算法通常都会使用递归









